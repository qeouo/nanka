<!DOCTYPE html>
<html>
<head>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="ja" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Script-Type" content="text/javascript" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Cache-Control" content="no-cache" />
<title>mapgen</title>
<style>
</style>
<script type="text/javascript" src="../lib/inherits.js"></script>
<script type="text/javascript" src="../lib/util.js"></script>
<script type="text/javascript" src="../lib/vector.js"></script>
<script type="text/javascript" src="../lib/openexr.js"></script>
<script type="text/javascript" src="../lib/zip.js"></script>
<script type="text/javascript" src="../lib/slider.js"></script>
<script type="text/javascript" src="../lib/colorpicker.js"></script>
<script type="text/javascript" src="../lib/geono.js"></script>
<script type="text/javascript" src="../lib/img.js"></script>
<style>
canvas{
	background-color:gray;
	zoom:400%;
	image-rendering:pixelated;
	border:0.25px solid black;
}
img{
	zoom:400%;
	border:0.25px solid black;
	margin:2px;
	image-rendering:pixelated;

}
img#img_pat{
}
img.hoge{
}
</style>

<script type="text/javascript">
"use strict"

var wave=[];
var N=3;
var HALF_N = N>>1;
var main_img;
var pattern_list=[];
var pattern_img;
var pattern_img2= new Img(N,N,1);
var Pattern= function(){
	this.x=0;
	this.y=0;
	this.num=0;
	this.joint=[(N+2)*(N+2)];
}
var copy=function(img0,x0,y0,img1,x,y,w,h){
	for(var yi=0;yi<h;yi++){
		for(var xi=0;xi<w;xi++){
			if(outcheck(x0+xi,y0+yi))continue;
			var idx0 = img0.getIndex(x0+xi,y0+yi);
			var idx1 = img1.getIndex(x+xi,y+yi);
			img0.rgba[idx0] = img1.rgba[idx1];
		}
	}
}
var checkPattern = function(pat,x,y,offsetx,offsety,px,py){
	//オフセットありパターン同士の一致チェック
	for(var yi=0;yi<N;yi++){
		for(var xi=0;xi<N;xi++){
			var idx = pat.getIndex(x+xi-HALF_N,y+yi-HALF_N);
			var ox = (xi-HALF_N)-offsetx;
			var oy = (yi-HALF_N)-offsety;
			if(ox<-HALF_N || ox>=N-HALF_N
				|| oy<-HALF_N || oy>=N-HALF_N){
				continue;
			}
			var idx1 = pat.getIndex(px+ox,py+oy);
			if(pat.rgba[idx] !== pat.rgba[idx1]){
				return false;
			}
		}
	}
	return true;

}

var outcheck=function(x,y){
	if(x<0 || x>=main_img.width
		|| y<0 || y>=main_img.height){
		return true;
	}
	return false;
}
var SIZE_1=64-1;
var mainGetIndex=function(x,y){
	return ((y&SIZE_1)<<6)+(x&SIZE_1);
}
var checkPatterns=function(x,y,pat_idx){
	//ある座標のあるパターンが成立するかチェック
	for(var yi=-2;yi<=2;yi++){
		for(var xi=-2;xi<=2;xi++){
			if(outcheck(x+xi,y+yi))continue;
			var list_index = (-yi+2)*5+(-xi+2);

			var idx = mainGetIndex(x+xi,y+yi);
			var wav = wave[idx];
			if(!wav){
				continue;
			}
			var flg=true;
			for(var i=0;i<wav.length;i++){
				var pat =pattern_list[wav[i]];
				if(pat.joint[list_index].indexOf(pat_idx)>=0){
					flg=false;
					break;
				}
			}
			if(flg){
				return false;
			}
		}
	}
	return true;

}
var updateWaveList=[];
var updateWave=function(x,y){
	var idx0 = mainGetIndex(x,y);
	var wav = wave[idx0];
	
	var old_num =pattern_img.width*pattern_img.height;

	if(!wav){
		wav=[];
		for(var wi=0;wi<pattern_list.length;wi++){
			if(checkPatterns(x,y,wi)){
				wav.push(wi);
			}
		}
		if(wav.length === pattern_list.length){
			wav=null;
		}
		wave[idx0]=wav;
	}else{
		old_num = wav.length;
		for(var i=wav.length;i--;){
			if(!checkPatterns(x,y,wav[i])){
				wav.splice(i,1);
			}
		}
	}
	if(wav){
		if(wav.length===0){
			console.log("A");
		}	
		if(wav.length===1){
			//確定した場合は描画
			var pat = pattern_list[wav[0]];
			copy(main_img,x-HALF_N,y-HALF_N,pattern_img,pat.x-HALF_N,pat.y-HALF_N,N,N);
		}	
		if(wav.length !== old_num){
			for(var yi=-2;yi<=2;yi++){
				for(var xi=-2;xi<=2;xi++){
					if(xi===0 && yi===0){
						continue;
					}
					if(outcheck(x+xi,y+yi))continue;
					
					var idx = mainGetIndex(x+xi,y+yi);
					if(wave[idx]){
						if(wave[idx].length===1){
							continue;
						}
					}
					if(updateWaveList.indexOf(idx)<0){
						updateWaveList.push(idx);
					}
				}
			}
		}
	}

}
var getPixel = function(x,y){
	var idx0 = mainGetIndex(x,y);

	var wav = wave[idx0];

	var idx;
	if(wav){
		if(wav.length===1){
			return false;
		}
		if(wav.length===0){
			main_img.rgba[idx0] = 0xffffff00;
			return true;
		}

		var sum=0;
		for(var i=0;i<wav.length;i++){
			sum+=pattern_list[wav[i]].num;
		}
		var r=Math.random()*sum|0;
		for(var i=0;i<wav.length;i++){
			r-=pattern_list[wav[i]].num;
			if(r<0){
				idx=wav[i];
				break;
			}
		}
		//idx = wav[Math.random()*wav.length|0];
	}else{
		var r=Math.random()*(pattern_img.width*pattern_img.height)|0;
		for(var i=0;i<pattern_list.length;i++){
			r-=pattern_list[i].num;
			if(r<0){
				idx=i;
				break;
			}
		}
	}

	wav = [idx];
	wave[idx0]=wav;
	var pat = pattern_list[wav[0]];
	copy(main_img,x-HALF_N,y-HALF_N,pattern_img,pat.x-HALF_N,pat.y-HALF_N,N,N);	

	for(var yi=-2;yi<=2;yi++){
		for(var xi=-2;xi<=2;xi++){
			if(xi===0 && yi===0){
				continue;
			}
			if(outcheck(x+xi,y+yi))continue;
			var idx = mainGetIndex(x+xi,y+yi);
			if(wave[idx]){
				if(wave[idx].length===1){
					continue;
				}
			}
			if(updateWaveList.indexOf(idx)<0){
				updateWaveList.push(idx);
			}
		}
	}

	while(updateWaveList.length){
		var p = updateWaveList.shift();
		updateWave(p&SIZE_1,p>>6);
	}
	
	return true;
}
var onloadfunc=function(e){
	var imgs=[];
		imgs.push(Img.loadImg("pat.png",1,function(img){

			createPattern(img);
		}));
	imgs.push(Img.loadImg("pat0.png",1));
	imgs.push(Img.loadImg("pat1.png",1));
	imgs.push(Img.loadImg("pat2.png",1));
	imgs.push(Img.loadImg("pat3.png",1));

	var s = document.getElementById("pat");
	for(var i=0;i<imgs.length;i++){
		var option =document.createElement("option");
		option.text=i;
		s.appendChild(option);
	}

	var createPattern=function(img){

		pattern_img= img;
		var pat  =document.getElementById("img_pat");
		pat.src = img.toDataUrl();

		var canvas = document.getElementById("c");
		main_img= new Img(canvas.width,canvas.height,1);


		pattern_list=[];
		//パターン収集
		for(var yi=0;yi<pattern_img.height;yi++){
			for(var xi=0;xi<pattern_img.width;xi++){
				var flg=true;
				for(var pi=0;pi<pattern_list.length;pi++){
					var pat = pattern_list[pi];

					if(checkPattern(pattern_img,xi,yi,0,0,pat.x,pat.y)){
						pat.num++;
						flg=false;
						break;
					}
				}
				if(flg){
					var pat = new Pattern();
					pat.x = xi;
					pat.y = yi;
					pat.num=1;
					pattern_list.push(pat);
				}
			}
		}

		//隣接パターン検索
		for(var pi=0;pi<pattern_list.length;pi++){
			var pat = pattern_list[pi];
			for(var yi=0;yi<5;yi++){
				for(var xi=0;xi<5;xi++){
					var list = [];
					pat.joint[yi*5+xi]=list;
					for(var pi2=0;pi2<pattern_list.length;pi2++){
						var pat2=pattern_list[pi2];
						if(checkPattern(pattern_img,pat.x,pat.y,xi-2,yi-2,pat2.x,pat2.y)){
							list.push(pi2);
						}
					}
				}
			}
		}

		var template_div = document.getElementById("pattern_template");
		var pattern_area = document.getElementById("pattern_area");
		while(pattern_area.firstChild)pattern_area.removeChild(pattern_area.firstChild);
		for(var pi=0;pi<pattern_list.length;pi++){
			var pat=pattern_list[pi];
			var pattern_div = template_div.cloneNode(true);
			copy(pattern_img2,0,0,pattern_img,pat.x-HALF_N,pat.y-HALF_N,N,N);
			pattern_div.getElementsByClassName("hoge")[0].src = pattern_img2.toDataUrl();
			var txt="x"+pat.num +" pos("+pat.x+","+pat.y+")";
			txt+= " 隣接情報" + JSON.stringify(pat.joint);
			var txtnode=document.createTextNode(txt);
			pattern_div.getElementsByClassName("status")[0].appendChild(txtnode);

			pattern_area.appendChild(pattern_div);

		}

	   reset();
	}
	var reset=function(){

		wave=new Array(main_img.width*main_img.height);
		for(var i=0;i<wave.length;i++){
			wave[i]=null;
		}

		for(var yi=0;yi<main_img.height;yi++){
			for(var xi=0;xi<main_img.width;xi++){
				var idx = yi * main_img.width + xi;
				main_img.rgba[idx]=0;
			}
		}
		var x=Math.random()*main_img.width|0;
		var y=Math.random()*main_img.height|0;
		
		var ctx =  c.getContext('2d')
		ctx.putImageData(main_img.toImageData(),0,0);
	}

	var pat = document.getElementById("pat");
	pat.addEventListener("change",function(e){
		createPattern(imgs[this.selectedIndex]);

	});
	   

	var do_flg=0;
	var f=function(){
		if(!do_flg){
			return;
		}
		var max=pattern_list.length+1;
		for(var wi=0;wi<wave.length;wi++){
			var s=pattern_list.length;
		   if(wave[wi]){
				s = wave[wi].length;
			}
			   if(s<max && s>1){
					max=s;
				}
			
		}
		if(max===pattern_list.length+1){
			do_flg=0;
			start.value="開始"
			return;
		}
		var kouho=[];
		if(max  === pattern_list.length){
			for(var wi=0;wi<wave.length;wi++){
				if(!wave[wi]){
					kouho.push(wi);
				}
			}
		}else{
			for(var wi=0;wi<wave.length;wi++){
				if(!wave[wi])continue;
				if(wave[wi].length===max){
					kouho.push(wi);
				}
			}
		}
		var idx = kouho[Math.random()*kouho.length|0];
		var x=idx&SIZE_1;
		var y=idx>>6;
		getPixel(x,y);
		
		var ctx =  c.getContext('2d')
		ctx.putImageData(main_img.toImageData(),0,0);
	   window.setTimeout(f,16);
	}
	var start = document.getElementById("start");
	start.addEventListener("click",function(e){
	   if(!do_flg){
			do_flg=1;
	   		start.value="一時停止"
			f();
	   }else{
	   		start.value="開始"
	   		do_flg=0;
	   }
	});

	document.getElementById("reset").addEventListener("click",function(e){
	   if(!do_flg){
			reset();
	   }
	});

}

</script>
</head>

<body onLoad="onloadfunc(event)">

	<canvas id="c" width="64" height="64" ></canvas>
	<img id="img_pat" >
	<select id="pat">
	</select>
	<input type="button" id="start" value="開始">
	<input type="button" id="reset" value="リセット">
	<br>
	<div style="display:none;">
		<div id="pattern_template">
			<img name="img" class="hoge">
			<span class="status"></span>
		</div>
	</div>
	<div id="pattern_area">
	</div>
</body>
</html>


