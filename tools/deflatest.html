<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="ja" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Script-Type" content="text/javascript" />
<title>Deflatest</title>
<style>
</style>
</head>
<script type="text/javascript" src="../lib/inherits.js"></script>
<script type="text/javascript" src="../lib/util.js"></script>
<script type="text/javascript">
"use strict"
var ctx,canvas;

var encLZSS=function(utf8array){
	var result=[];

	for(var i=0;i<utf8array.length;i++){
		var target = utf8array[i];
		var kouho={};
		var kmax=2;
		for(var j=Math.max(0,i-32767);j<i;j++){
			if(utf8array[i] === utf8array[j]){
				for(var k=0;utf8array[i+k] === utf8array[j+k] && k<=285;k++){
				}
				if(k>kmax){
					kouho=i-j
					kmax=k;
				}
			}
		}
		if(kmax>2){
			result.push({len:kmax,dist:kouho});
			i+=kmax-1;
		}else{
			result.push(utf8array[i]);
		}
	}
	return result;
}
var decLZSS=function(data){
	var idx=0;
	var decode=[];
	for(var i=0;i<data.length;i++){
		if(!isNaN(data[i])){
			decode.push(data[i]);
		}else{
			idx=decode.length-data[i].dist;
			for(var j=0;j<data[i].len;j++){
				decode.push(decode[idx+j]);
			}
		}
	}
	return decode;

}

var tree=[];
var dectree=[];
const MAX_BITS=10;
var createHaffmanTree=function(){
	for(var i=0;i<288;i++){
		tree.push({});
	}

	for(var i=0;i<=143;i++){ tree[i].Len=8;}
	for(var i=144;i<=255;i++){ tree[i].Len=9;}
	for(var i=256;i<=279;i++){ tree[i].Len=7;}
	for(var i=280;i<=287;i++){ tree[i].Len=8;}

	var bl_count=new Array(MAX_BITS+1);
	for(var i=0;i<bl_count.length;i++){
		bl_count[i]=0;
	}
	for(var i=0;i<tree.length;i++){
		bl_count[tree[i].Len]++;
	}
   var code = 0;
   var next_code = new Array(MAX_BITS+1);
   for (var bits = 1; bits <= MAX_BITS; bits++) {
       code = (code + bl_count[bits-1]) << 1;
       next_code[bits] = code;
   }
   var max_code=287;
   for (var n = 0; n <= max_code; n++) {
       var len = tree[n].Len;
       if (len != 0) {
           tree[n].Code = next_code[len];
           next_code[len]++;
       }
   }

	for(var i=0;i<=287;i++){
		dectree[tree[i].Code]={};
		dectree[tree[i].Code].Code=i;
		dectree[tree[i].Code].Len=tree[i].Len;
	}

}
var encHaffman=function(src){
	var result=[];
	for(var i=0;i<src.length;i++){
		if(isNaN(src[i])){
			var a={};
			a.dist=tree[src[i].dist];
			var code = src[i].len ;
			var extra_bits=((Math.log2(Math.max(src[i].len-3,4)))|0)-2;
			a.code =extra_bits*4+((src[i].len-3)>>extra_bits) + 257;
			a.extra_data=(src[i].len-3) & ((1<<extra_bits)-1);

			a.code=tree[a.code].Code;

			result.push(a.code);
			result.push(a.extra_data);
			result.push(src[i].dist);

			a.len=tree[src[i].len].Code;
			//result.push(a);
		}else{
			result.push(tree[src[i]].Code);
		}
	}

	return result;
}
var decHaffman=function(src){
	var decdata=[];
	for(var i=0;i<src.length;i++){
		var code =dectree[src[i]].Code;

		if(code>=257){
			var a ={};
			i++;
			var extra_data = src[i];
			i++;
			a.dist = src[i];
			var extra_bits = code-261;
			if(extra_bits>=0){
				extra_bits = extra_bits>>2;
				code=code-257;
				var offset = 4+(extra_bits*4)
				code=((code -offset)<<extra_bits) + (4<<extra_bits) + extra_data;
			}else{
				extra_bits=0;
				code=code-257;
			}
			
			
			//a.len=dectree[src[i].len];
			a.len=code+3;
			decdata.push(a);
		}else{
			decdata.push(dectree[src[i]].Code);
		}
	}
	return decdata;

}
var output_index=0;
var output_buffer=[];
var outputBit=function(bit){
	output_buffer[output_index>>3] &=  ~(1<<(output_index&7));

	output_buffer[output_index>>3] |=bit<<(output_index&7);
	output_index++;
}
var outputBits=function(bits,len){
	for(var i=0;i<len;i++){
		outputBit((bits>>i)&1);
	}
}
var outputBitsReverse=function(bits,len){
	for(var i=len-1;i>=0;i--){
		outputBit((bits>>i)&1);
	}
}
var createBlock=function(src){
	output_index=0;
	output_buffer=[];
	//BFINAL
	outputBit(1);

	//complession type
	outputBit(0);
	outputBit(1);

	//data
	for(var i=0;i<src.length;i++){
		if(isNaN(src[i])){
			var a={};
			a.dist=tree[src[i].dist];
			var code = src[i].len ;
			var extra_bits=((Math.log2(Math.max(src[i].len-3,4)))|0)-2;
			code =extra_bits*4+((src[i].len-3)>>extra_bits) + 257;
			var extra_data=(src[i].len-3) & ((1<<extra_bits)-1);

			var t=tree[code];

			outputBitsReverse(t.Code,t.Len);
			outputBits(extra_data,extra_bits);

//距離ハフマン
			code = src[i].dist ;
			extra_bits=((Math.log2(Math.max(src[i].dist-1,2)))|0)-1;
			code =extra_bits*2+((src[i].dist-1)>>extra_bits) ;
			var extra_data=(src[i].dist-1) & ((1<<extra_bits)-1);

			outputBitsReverse(code,5);
			outputBits(extra_data,extra_bits);

		}else{
			var t =tree[src[i]];
			outputBitsReverse(t.Code,t.Len);
		}
	}
	outputBits(tree[256].Code,tree[256].Len);
}
var readBit=function(){
	var bit=(output_buffer[output_index>>3] >> (output_index&7))&1;
	output_index++;
	return bit;

}
var readBitsReverse=function(len){
	var bits=0;
	for(var i=0;i<len;i++){
		bits=(bits<<1) | readBit();
	}
	return bits;
}
var readBits=function(len){
	var bits=0;
	for(var i=0;i<len;i++){
		bits=bits | (readBit()<<i);
	}
	return bits;
}
var decBlock=function(){
	var decdata=[];
	output_index=0;
	var data =readBit();
	data =readBits(2);

	while(1){
		var value;
		for(var i=1;i<=MAX_BITS;i++){
			value =readBitsReverse(i); 
			if(dectree[value]){
				if(dectree[value].Len === i){
					value = dectree[value].Code;
					break;
				}
			}
			output_index-=i;

		}

		if(value <256){
			decdata.push(value);
		}else{
			if(value ==256){
				break;
			}
			var a ={};

			var extra_bits = value-261;
			if(extra_bits>=0){
				extra_bits = extra_bits>>2;
				value =value-257;
				var offset = 4+(extra_bits*4);
				var extra_data = readBits(extra_bits);
				value =((value -offset)<<extra_bits) + (4<<extra_bits) + extra_data;
			}else{
				value =value -257;
			}
			a.len=value+3;


			value = readBitsReverse(5);
			extra_bits = value -2;
			if(extra_bits>=0){
				extra_bits = extra_bits>>1;
				var offset = 2+(extra_bits*2);
				var extra_data = readBits(extra_bits);
				value =((value -offset)<<extra_bits) + (2<<extra_bits) + extra_data;
			}
			a.dist=value+1;
			decdata.push(a);
		}
	}
	return decdata;

}

var format=function(src){
	var result="";
	for(var i=0;i<src.length;i++){
		if(i!==0){
			result+=",";
		}

		if(isNaN(src[i])){
	 		result+="&lt;"+src[i].len.toString(10)+","+src[i].dist.toString(10)+"&gt;";
		}else{
			result+=src[i].toString(10);
		}
	}
	return result;
}
var formatHaffman=function(){
	var result="";
	for(var i=0;i<output_buffer.length;i++){
		if(i!==0){
			result+=",";
		}
		result+=('00000000' +output_buffer[i].toString(2)).slice(-8);
	}
	return result;
}
var onloadfunc=function(e){
	var src = document.getElementById("src");
	var output= document.getElementById("output");

	src.addEventListener("input",function(evt){
		var output_str="";
		var str = src.value;
		if(str.length===0){
			output.innerHTML="";
			return;
		}
		var utf8array=[];
		var utf8str = unescape(encodeURIComponent(str));
		for(var i=0;i<utf8str.length;i++){
			utf8array.push(utf8str.charCodeAt(i));
		}
		output_str+="\n\n↓エンコード\n"
		output_str+="UTF8("+utf8array.length+"byte):"+format(utf8array)+"\n";

		var result = encLZSS(utf8array);
		output_str+="LZ77符号化:"+format(result)+"\n";

		createHaffmanTree();
		var haff = encHaffman(result);

		//output_str+="ハフマンテーブル:";
		//for(var key in table){
		//	output_str+=","+Number(table[key]).toString(16) +"→"+Number(key).toString(2).substr(1);
		//}
		output_str+="\n";

		createBlock(result);
		output_str+="ハフマン符号化("+ output_buffer.length+"byte):"+formatHaffman()+"\n";

		output_str+="\n\n↓こっからデコード\n"
		result = decHaffman(haff);

		result =decBlock();
		output_str+="ハフマン復号化:"+format(result)+"\n";

		var decode=decLZSS(result);
		output_str+="LZ77復号化:"+format(decode)+"\n";

		var aaa ="";
		for(var i=0;i<decode.length;i++){
	  		aaa+=String.fromCharCode(decode[i]);
		}
		var utf16str = decodeURIComponent(escape(aaa));	
		output_str+="復号結果:"+utf16str+"\n";

		output.innerHTML = output_str;


	});

	Util.fireEvent(src,"input");


}

</script>

<body onLoad="onloadfunc(event)">

元<input type="text" id ="src" size="128" value="うらにわにはにわにわにはにわにわとりがいる"><br>
<div id="output" style="white-space:pre;"><div>
</body>
</html>

