<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="ja" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Script-Type" content="text/javascript" />
<title>Deflatest</title>
<style>
</style>
</head>
<script type="text/javascript" src="../lib/inherits.js"></script>
<script type="text/javascript" src="../lib/util.js"></script>
<script type="text/javascript">
"use strict"
var output_str="";
var ctx,canvas;

var encLZSS=function(utf8array){
	var result=[];

	for(var i=0;i<utf8array.length;i++){
		var dist=0;
		var len_max=2;
		for(var j=Math.max(0,i-32767);j<i;j++){
			if(utf8array[i] === utf8array[j]){
				var k=0;
				for(; k<=285;k++){
					if(utf8array[i+k] !== utf8array[j+k] ){
						break;
					}
				}
				if(k>len_max){
					dist=i-j
					len_max=k;
				}
			}
		}
		if(len_max>2){
			result.push({len:len_max,dist:dist});
			i+=len_max-1;
		}else{
			result.push(utf8array[i]);
		}
	}
	return result;
}
var decLZSS=function(data){
	var idx=0;
	var decode=[];
	for(var i=0;i<data.length;i++){
		if(!isNaN(data[i])){
			decode.push(data[i]);
		}else{
			idx=decode.length-data[i].dist;
			for(var j=0;j<data[i].len;j++){
				decode.push(decode[idx+j]);
			}
		}
	}
	return decode;

}

var clen_tree=[];
var len_tree=[];
var dist_tree=[];
const MAX_BITS=15;
var createHaffmanTree=function(lens){
	var enc_tree=[];
	var max_bits=0;
	for(var i=0;i<lens.length;i++){
		var t = {};
		t.Len = lens[i];
		t.Code  = 0;
		enc_tree.push(t);

		if(max_bits<lens[i]){
			max_bits = lens[i];
		}
	}


	var bl_count=new Array(max_bits+1);
	for(var i=0;i<bl_count.length;i++){
		bl_count[i]=0;
	}
	for(var i=0;i<enc_tree.length;i++){
		bl_count[enc_tree[i].Len]++;
	}
   var code = 0;
   var next_code = new Array(max_bits+1);
   for (var bits = 1; bits <next_code.length; bits++) {
       code = (code + bl_count[bits-1]) << 1;
       next_code[bits] = code;
   }
   for (var n = 0; n < enc_tree.length; n++) {
       var len = enc_tree[n].Len;
       if (len != 0) {
           enc_tree[n].Code = next_code[len];
           next_code[len]++;
       }
   }

	var dec_tree={};
	for(var i=0;i<enc_tree.length;i++){
		dec_tree[enc_tree[i].Code]=i;
	}

	var haffman_tree={};
	haffman_tree.enc_tree=enc_tree;
	haffman_tree.dec_tree=dec_tree;

	return haffman_tree;
}
var output_index=0;
var output_buffer=[];
var outputBit=function(bit){
	output_buffer[output_index>>3] &=  ~(1<<(output_index&7));

	output_buffer[output_index>>3] |=bit<<(output_index&7);
	output_index++;
}
var outputBits=function(bits,len){
	for(var i=0;i<len;i++){
		outputBit((bits>>i)&1);
	}
}
var outputBitsReverse=function(bits,len){
	for(var i=len-1;i>=0;i--){
		outputBit((bits>>i)&1);
	}
}
var encHaffman=function(tree,value){
	return tree.enc_tree[value];
}
var outputHaffman=function(tree,value){
	var t = tree.enc_tree[value];
	outputBitsReverse(t.Code,t.Len);
}

var outputClen=function(src,tree){
	for(var i=0;i<src.length;i++){
		var value = src[i];
		if(value<=15){
			outputHaffman(tree,value);
		}else if(value===16){
				outputHaffman(tree,value);
				i++;
				outputBits(src[i],2);
	}else if(value===17){
				outputHaffman(tree,value);
				i++;
				outputBits(src[i],3);
	}else if(value===18){
				outputHaffman(tree,value);
				i++;
				outputBits(src[i],7);
			}
		}
}
var encBlock=function(src){
	output_index=0;
	output_buffer=[];
	var li_list = [];
	var dist_list = [];
	var clen_list = [];

	//BFINAL
	outputBit(1);

	var comp_type=0b10;
	//complession type
	outputBits(comp_type,2);
	if(comp_type===0b01){
		//固定
		//リテラルビット長リスト
		for(var i=0;i<=143;i++){ li_list[i]=8;}
		for(var i=144;i<=255;i++){ li_list[i]=9;}
		for(var i=256;i<=279;i++){ li_list[i]=7;}
		for(var i=280;i<=287;i++){ li_list[i]=8;}



		//距離ビット長リスト
		for(var i=0;i<=31;i++){ dist_list[i]=5;}

	}else if(comp_type===0b10){

		//コード長コードビット長リスト
		for(var i=0;i<19;i++){
			clen_list.push(5);
		}
		//コード長コードハフマンツリー作成
		clen_tree = createHaffmanTree(clen_list);

		//リテラルビット長リスト
		for(var i=0;i<=143;i++){ li_list[i]=8;}
		for(var i=144;i<=255;i++){ li_list[i]=9;}
		for(var i=256;i<=279;i++){ li_list[i]=7;}
		for(var i=280;i<=287;i++){ li_list[i]=8;}

		//距離ビット長リスト
		for(var i=0;i<=31;i++){ dist_list[i]=5;}



		//リテラル数
		outputBits(li_list.length-257,5);

		//距離数
		outputBits(dist_list.length-1,5);

		//コード長コード数
		outputBits(clen_list.length-4,4);

		//コード長コードエンコ
		for(var i=0;i<clen_list.length;i++){
			outputBits(clen_list[i],3);
		}

		//リテラルビット長リストエンコ
		var enc = encodeClen(li_list,clen_tree);
		outputClen(enc,clen_tree);

		//距離ビット長リストエンコ
		enc = encodeClen(dist_list,clen_tree);
		outputClen(enc,clen_tree);
	}
	//リテラルハフマンツリー
	len_tree = createHaffmanTree(li_list);
	//距離ハフマンツリー
	dist_tree = createHaffmanTree(dist_list);

	//data
	for(var i=0;i<src.length;i++){
		if(isNaN(src[i])){
			var a={};
			var code = src[i].len ;
			var extra_bits=((Math.log2(Math.max(src[i].len-3,4)))|0)-2;
			code =extra_bits*4+((src[i].len-3)>>extra_bits) + 257;
			var extra_data=(src[i].len-3) & ((1<<extra_bits)-1);

			outputHaffman(len_tree,code);
			outputBits(extra_data,extra_bits);

//距離ハフマン
			code = src[i].dist ;
			extra_bits=((Math.log2(Math.max(src[i].dist-1,2)))|0)-1;
			code =extra_bits*2+((src[i].dist-1)>>extra_bits) ;
			var extra_data=(src[i].dist-1) & ((1<<extra_bits)-1);

			outputHaffman(dist_tree,code);
			outputBits(extra_data,extra_bits);

		}else{
			outputHaffman(len_tree,src[i]);
		}
	}
	outputHaffman(len_tree,256);
}
var readBit=function(){
	var bit=(output_buffer[output_index>>3] >> (output_index&7))&1;
	output_index++;
	return bit;

}
var readBitsReverse=function(len){
	var bits=0;
	for(var i=0;i<len;i++){
		bits=(bits<<1) | readBit();
	}
	return bits;
}
var readBits=function(len){
	var bits=0;
	for(var i=0;i<len;i++){
		bits=bits | (readBit()<<i);
	}
	return bits;
}
var readHaffman = function(tree){
	var dec_tree=tree.dec_tree;
	var enc_tree=tree.enc_tree;
	for(var i=1;i<=MAX_BITS;i++){
		var value =readBitsReverse(i); 
		var deccode = dec_tree[value];
		if(deccode != null){
			if(enc_tree[deccode].Len === i){
				return deccode;
			}
		}
		
		output_index-=i;

	}
	return null;
}
var encodeClen=function(lens){
	var clen=[];
	for(var i=0;i<lens.length;i++){
		var target = lens[i];
		var count=1;
		for(;count+i<lens.length && target===lens[i+count];count++){ }
		i+=count-1;
		if(target===0){
			while(count){
				if(count<3){
					clen.push(0);
					count-=1;
				}else if(count<11){
					clen.push(17);
					clen.push(count-3);
					count=0;
				}else if(count<139){
					clen.push(18);
					clen.push(count-11);
					count=0;
				}else{
					clen.push(18);
					clen.push(127);
					count-=138;
				}
			}
		}else{
			clen.push(target);
			count-=1;
			while(count){
				if(count<3){
					clen.push(target);
					count-=1;
				}else if(count<7){
					clen.push(16);
					clen.push(count-3);
					count=0;
				}else{
					clen.push(16);
					clen.push(3);
					count-=6;
				}
			}
		}
		
	}
	return clen;



}
var decodeClen=function(size,clen_tree){
	var lens=[];
	while(1){
		if(lens.length>=size){
			break;
		}
		var value = readHaffman(clen_tree);
		if(value<=15){
			lens.push(value);
		}else if(value===16){
			//直前値3~6コピー
			var extra = readBits(2);
			var org = lens[lens.length-1];
			
			for(var j=0;j<extra+3;j++){
				lens.push(org);
			}
		}else if(value===17){
			//3~10ゼロ埋め
			var extra = readBits(3);
			
			for(var j=0;j<extra+3;j++){
				lens.push(0);
			}
		}else if(value===18){
			//11~138ゼロ埋め
			var extra = readBits(7);
			
			for(var j=0;j<extra+11;j++){
				lens.push(0);
			}
		}
		
	}
	return lens;

}
var decBlock=function(){
	var decdata=[];
	var bfinal = 0;

	while(!bfinal){
		bfinal =readBit();
		var compless_type=readBits(2);

		if(compless_type===0b00){
			//無圧縮
			if(output_index&7){
				output_index = (output_index&~7)+8;
			}else{
				output_index = (output_index&~7);
			}
			var len=readBits(8);
			readBits(8);
			for(var i=0;i<len;i++){
				decdata.push(readBits(8));
			}
			output_index+=len*8;
		}else if(compless_type === 0b01 || compless_type===0b10){
			var lens =[];
			if(compless_type===0b01){
				//固定ハフマン
				for(var i=0;i<=143;i++){ lens[i]=8;}
				for(var i=144;i<=255;i++){ lens[i]=9;}
				for(var i=256;i<=279;i++){ lens[i]=7;}
				for(var i=280;i<=287;i++){ lens[i]=8;}
				len_tree = createHaffmanTree(lens);

				lens =[];
				for(var i=0;i<=31;i++){ lens[i]=5;}
				dist_tree = createHaffmanTree(lens);
			}else{
				//ダイナミックハフマン
				var hlit = readBits(5);
				var hdist = readBits(5);
				var hclen = readBits(4);

				//コード長コード復号
				var idx = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
			
				for(var i=0;i<idx.length;i++){
					if(i<hclen+4){
						lens[idx[i]]=readBits(3);
					}else{
						lens[idx[i]]=0;
					}
				}
				var clen_tree = createHaffmanTree(lens);

				//長さビット長リスト復元
				lens = decodeClen(hlit+257,clen_tree);
				len_tree = createHaffmanTree(lens);

				//距離ビット長リスト復元
				lens = decodeClen(hlit+1,clen_tree);
				dist_tree = createHaffmanTree(lens);
			}

			while(1){
				var value = readHaffman(len_tree);

				if(value <256){
					//リテラル
					decdata.push(value);
				}else{
					if(value ==256){
						//終了符号
						break;
					}
					var a ={};

					//長さ
					var extra_bits = value-261;
					if(extra_bits>=0){
						extra_bits = extra_bits>>2;
						value =value-257;
						var offset = 4+(extra_bits*4);
						var extra_data = readBits(extra_bits);
						value =((value -offset)<<extra_bits) + (4<<extra_bits) + extra_data;
					}else{
						value =value -257;
					}
					a.len=value+3;


					//距離
					value = readHaffman(dist_tree);
					//value = readBitsReverse(5);
					extra_bits = value -2;
					if(extra_bits>=0){
						extra_bits = extra_bits>>1;
						var offset = 2+(extra_bits*2);
						var extra_data = readBits(extra_bits);
						value =((value -offset)<<extra_bits) + (2<<extra_bits) + extra_data;
					}
					a.dist=value+1;
					decdata.push(a);
				}
			}
		}
	}
	return decdata;

}


var format=function(src){
	var result="";
	for(var i=0;i<src.length;i++){
		if(i!==0){
			result+=",";
		}

		if(isNaN(src[i])){
	 		result+="&lt;"+src[i].len.toString(10)+","+src[i].dist.toString(10)+"&gt;";
		}else{
			result+=src[i].toString(10);
		}
	}
	return result;
}
var formatHaffman=function(){
	var result="";
	for(var i=0;i<output_buffer.length;i++){
		if(i!==0){
			result+=",";
		}
		result+=('00000000' +output_buffer[i].toString(2)).slice(-8);
	}
	return result;
}

 var encodeDeflate=function(src){
	var result = encLZSS(src);
	output_str+="LZ77符号化:"+format(result)+"\n";


	output_str+="\n";

	encBlock(result);
	output_str+="ハフマン符号化("+ output_buffer.length+"byte):"+formatHaffman()+"\n";

	return  output_buffer;
}

	 var decodeDeflate=function(src){
		output_index=0;
		output_str+="\n\n↓こっからデコード\n"

		var result =decBlock(src);
		output_str+="ハフマン復号化:"+format(result)+"\n";

		var decode=decLZSS(result);
		output_str+="LZ77復号化:"+format(decode)+"\n";

	 	return decode;
	 }
var onloadfunc=function(e){
	var src = document.getElementById("src");
	var output= document.getElementById("output");

	src.addEventListener("input",function(evt){
	 	output_str="";
		var str = src.value;
		if(str.length===0){
			output.innerHTML=output_str;
			return;
		}
		var utf8array=[];
		var utf8str = unescape(encodeURIComponent(str));
		for(var i=0;i<utf8str.length;i++){
			utf8array.push(utf8str.charCodeAt(i));
		}
		output_str+="\n\n↓エンコード\n"
		output_str+="UTF8("+utf8array.length+"byte):"+format(utf8array)+"\n";

		var encoded =encodeDeflate(utf8array);

   		var decode = decodeDeflate(encoded);

		var aaa ="";
		for(var i=0;i<decode.length;i++){
	  		aaa+=String.fromCharCode(decode[i]);
		}
		var utf16str = decodeURIComponent(escape(aaa));	
		output_str+="復号結果:"+utf16str+"\n";

		output.innerHTML = output_str;


	});

	Util.fireEvent(src,"input");


}

</script>

<body onLoad="onloadfunc(event)">

元<input type="text" id ="src" size="128" value="うらにわにはにわにわにはにわにわとりがいる"><br>
<div id="output" style="white-space:pre;"><div>
</body>
</html>

