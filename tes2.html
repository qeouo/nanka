<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=Edge"/>
<meta charset="utf-8">
</head>
<body>
	<div id="hoge"></div>
	<canvas id="c" width=256 height=256 style="border:solid 1px black;" ></canvas>
	<input type="button" value="reset" id="reset"/>
</body>
<script type="text/javascript">
var MAX = 3 + 30;
var FPS = 30;
var STEP_PER_FRAME = 4;
var REPETITION_MAX = 99; 
var G = 9.8; 
var SCALE = 0.01; 

var Obj = function() {
	this.id = 0;
	this.location = new Vec2();
	this.locationV = new Vec2();
	this.old_locationV = new Vec2();
	this.rotation = 0;
	this.rotationV = 0;
	this.old_rotationV= 0;
	this.size = 0.05; 
	this.mass = 0.01; 
	this.moment = 2.0 / 5.0 * this.mass * this.size * this.size;
	this.inv_mass = 1.0 / this.mass; 
	this.inv_massoment = 1.0 / this.moment; 
	this.inv_restCoe = 1.0/0.2; 
	this.inv_fricCoe = 1.0/0.2; 
}
var HitInfo = function() {
	this.obj1 = null;
	this.obj2 = null;
	this.pos1 = new Vec2();
	this.pos2 = new Vec2();
	this.nVec = new Vec2();
	this.nEffic = 0;
	this.nImpulse = 0; 
	this.tVec = new Vec2();
	this.tEffic= 0;
	this.tImpulse = 0; 
	this.restCoe = 0; 
	this.fricCoe = 0;
}
var impulseBuf = function() {
	this.id0 = 0;
	this.id1 = 0;
	this.nImpulse = 0;
	this.tImpulse = 0;
}
var hitInfos = [];
var impulseBufs = [];
var hitInfosMAX = MAX * 8;
for (var i = hitInfosMAX; i--;) {
	hitInfos.push(new HitInfo());
	impulseBufs.push(new impulseBuf());
}
impulseBufs.push(new impulseBuf());

var objs = [];
for (var i = 0; i < MAX; i++) {
	objs.push(new Obj());
}
var init = document.getElementById("reset").onclick = function(){
	for (var i = 0; i < MAX; i++) {
		var obj = objs[i];
		obj.id = i;
		obj.location[0] = 128 * SCALE + ((Math.random() - 0.5) * 1);
		obj.location[1] = 168 * SCALE - i * 0.1;
		obj.locationV[0]= 0;
		obj.locationV[1]= 0;
		obj.rotation = 0;
		obj.rotationV = 0;
		obj.size = 0.05 + Math.random() * 0.2;
		obj.mass = obj.size*obj.size*10;
		obj.moment = 2.0 / 5.0 * obj.mass * obj.size * obj.size;
		obj.inv_mass = 1.0 / obj.mass;
		obj.inv_massoment = 1.0 / obj.moment;
	}

	objs[0].size = 512 * SCALE;
	objs[0].mass = 99999;
	objs[0].inv_mass = 0;
	objs[0].moment = 99999;
	objs[0].inv_massoment = 0;
	objs[0].location[0] = 128 * SCALE;
	objs[0].location[1] = 220 * SCALE + objs[0].size
	objs[1].size = 512 * SCALE;
	objs[1].mass = 99999;
	objs[1].inv_mass = 0;
	objs[1].moment = 99999;
	objs[1].inv_massoment = 0;
	objs[1].location[0] = 220 * SCALE + objs[1].size;
	objs[1].location[1] = 128 * SCALE;
	objs[2].mass = 99999;
	objs[2].inv_mass = 0;
	objs[2].moment = 99999;
	objs[2].inv_massoment = 0;
	objs[2].size = 512 * SCALE;
	objs[2].location[0] = 32 * SCALE - objs[1].size;
	objs[2].location[1] = 128 * SCALE;

	impulseBufs[0].id0 = MAX;
}



var calcEffic = function(n, hitInfo) {
	var obj1 = hitInfo.obj1;
	var obj2 = hitInfo.obj2;
	var t = cross(n, hitInfo.pos1);
	var d = t * t * obj1.inv_massoment;
	t = cross(n, hitInfo.pos2);
	d += t * t * obj2.inv_massoment;
	return 1 / (obj1.inv_mass + obj2.inv_mass + dot(n, hitInfo.tVec) * d);
}

var calcDiffVelocity = function(dv,hitInfo){
	var obj1 = hitInfo.obj1;
	var obj2 = hitInfo.obj2;
	sub(dv, obj2.locationV, obj1.locationV);
	dv[0] -= -hitInfo.pos1[1] * obj1.rotationV;
	dv[1] -= hitInfo.pos1[0] * obj1.rotationV;
	dv[0] += -hitInfo.pos2[1] * obj2.rotationV;
	dv[1] += hitInfo.pos2[0] * obj2.rotationV;
}

var addimpulse = function(hitInfo,impulse){
	var obj1 = hitInfo.obj1;
	var obj2 = hitInfo.obj2;

	if(obj1.inv_mass > 0){
		muladd(obj1.locationV,obj1.locationV,impulse, obj1.inv_mass);
		obj1.rotationV += cross(hitInfo.pos1, impulse) * obj1.inv_massoment;
	}
	if(obj2.inv_mass > 0){
		muladd(obj2.locationV,obj2.locationV,impulse, -obj2.inv_mass);
		obj2.rotationV += -cross(hitInfo.pos2, impulse) * obj2.inv_massoment;
	}
}

var repetition = 0; 
var f = function(dt) {
	var dp = new Vec2();
	var dv = new Vec2(); 
	var impulse = new Vec2();

	hitInfosCount = 0;
	impulseBufsCount = 0;
	for (var i = 0; i < MAX; i++) {
		var obj1 = objs[i];
		for (var j = i + 1; j < MAX; j++) {
			var obj2 = objs[j];

			if(hitInfosCount>=hitInfos.length-1){
				break;
			}
			sub(dp, obj2.location, obj1.location);
			if (dp[0] * dp[0] + dp[1] * dp[1] < (obj1.size + obj2.size) * (obj1.size + obj2.size)) {
				if (obj1.inv_mass == 0 && obj2.inv_mass == 0) {
					continue;
				}
				var hitInfo = hitInfos[hitInfosCount];
				hitInfosCount++;

				hitInfo.obj1 = obj1;
				hitInfo.obj2 = obj2;
				hitInfo.nImpulse = 0;
				hitInfo.tImpulse = 0;
				var d = Math.sqrt(dp[0] * dp[0] + dp[1] * dp[1])
				if (d != 0) {
					mul(hitInfo.nVec, dp, -1 / d);
				} else {
					mul(hitInfo.nVec, dp, 0);
				}
				hitInfo.tVec[0] = -hitInfo.nVec[1];
				hitInfo.tVec[1] = hitInfo.nVec[0];
				mul(hitInfo.pos1, hitInfo.nVec, -obj1.size);
				mul(hitInfo.pos2, hitInfo.nVec, obj2.size);
				hitInfo.nEffic = calcEffic(hitInfo.nVec, hitInfo);
				hitInfo.tEffic = calcEffic(hitInfo.tVec, hitInfo);

				hitInfo.fricCoe = 2.0/(obj1.inv_fricCoe + obj2.inv_fricCoe);

				sub(dv, obj2.locationV, obj1.locationV);
				hitInfo.repulsion = dot(dv, hitInfo.nVec) * 2 / (obj1.inv_restCoe + obj2.inv_restCoe)*hitInfo.nEffic;

				for (; 1; impulseBufsCount++) {
					var impulseBuf = impulseBufs[impulseBufsCount];
					if (impulseBuf.id0 > i || (impulseBuf.id0 ==i && impulseBuf.id1 > j)) {
						break;
					}
					if (impulseBuf.id0 == i && impulseBuf.id1 == j) {
						hitInfo.nImpulse = impulseBuf.nImpulse;
						hitInfo.tImpulse = impulseBuf.tImpulse;
						break;
					}
				}
			}
		}
	}

	hitInfos[hitInfosCount].obj1=null;

	for (var i = 0;hitInfos[i].obj1; i++) {
		var hitInfo = hitInfos[i];

		mul(impulse, hitInfo.nVec, hitInfo.nImpulse );
		muladd(impulse, impulse, hitInfo.tVec, hitInfo.tImpulse );
		addimpulse( hitInfo, impulse);
	}

	for (var i = 0; i < MAX; i++) {
		var obj = objs[i];
		if (obj.inv_mass > 0) {
			obj.locationV[1]+=G*dt;
		}
	}
	for (repetition = 0; repetition < REPETITION_MAX; repetition++) {
		for (var i = 0; i < MAX; i++) {
			var o = objs[i];

			o.old_locationV[0] = o.locationV[0] ;
			o.old_locationV[1] = o.locationV[1] ;
			o.old_rotationV = o.rotationV ;
		}

		for (var i = 0;hitInfos[i].obj1; i++) {
			var hitInfo = hitInfos[i];

			calcDiffVelocity(dv,hitInfo);
			var old = hitInfo.nImpulse;
			hitInfo.nImpulse += dot(dv, hitInfo.nVec) * hitInfo.nEffic + hitInfo.repulsion;
			if (hitInfo.nImpulse < 0) {
				hitInfo.nImpulse = 0;
			}
			mul(impulse, hitInfo.nVec, (hitInfo.nImpulse-old));
			addimpulse( hitInfo, impulse);

			calcDiffVelocity(dv,hitInfo);
			var max = hitInfo.nImpulse * hitInfo.fricCoe;
			old = hitInfo.tImpulse;
			hitInfo.tImpulse += dot(dv, hitInfo.tVec)* hitInfo.tEffic;
			if (hitInfo.tImpulse > max) {
				hitInfo.tImpulse = max;
			}
			if (hitInfo.tImpulse < -max) {
				hitInfo.tImpulse = -max;
			}
			mul(impulse, hitInfo.tVec, (hitInfo.tImpulse-old));
			addimpulse( hitInfo, impulse);
		}

		var sum= 0;
		for (var i = 0; i < MAX; i++) {
			var obj = objs[i];
			var x = (obj.locationV[0] - obj.old_locationV[0])*obj.mass;
			var y = (obj.locationV[1] - obj.old_locationV[1])*obj.mass;
			var z = (obj.rotationV - obj.old_rotationV)*obj.moment;
			sum+=x*x+y*y+z*z ;
		}
		if ( sum<= 0.0000001 ) {
			break;
		}
	}

	var PENALTY = 1000;
	for (var i = 0;hitInfos[i].obj1; i++) {
		var hitInfo = hitInfos[i];

		add(dp, hitInfo.pos2, hitInfo.obj2.location);
		sub(dp, dp, hitInfo.obj1.location);
		sub(dp, dp, hitInfo.pos1);
		mul(impulse, dp, PENALTY*dt*hitInfo.nEffic);
		addimpulse(hitInfo,impulse);
	}

	for (var i = 0; i < MAX; i++) {
		var obj = objs[i];
		if (obj.inv_mass ==0 ) continue;

		muladd(obj.location, obj.location, obj.locationV, dt);
		obj.rotation += obj.rotationV * dt;
	}

	for (var i = 0;hitInfos[i].obj1; i++) {
		var impulseBuf = impulseBufs[i];
		var hitInfo = hitInfos[i];

		impulseBuf.id0 = hitInfo.obj1.id;
		impulseBuf.id1 = hitInfo.obj2.id;
		impulseBuf.nImpulse = hitInfo.nImpulse;
		impulseBuf.tImpulse = hitInfo.tImpulse;
	}
	impulseBufs[i].id0 = MAX;
}
var timesum = 0;
var framecount = 0;
var msec= 0;
var ctx = document.getElementById("c").getContext("2d");
var ml = function() {

	var start = Date.now();
	for (var i = 0; i < STEP_PER_FRAME; i++) {
		f( 1/ (FPS * STEP_PER_FRAME) );
	}
	timesum += (+Date.now() - start);
	framecount++;
	if (framecount == FPS) {
		msec= timesum / FPS;
		framecount = 0;
		timesum = 0;
	}

	ctx.clearRect(0, 0, 256, 256);
	ctx.strokeStyle = "black";
	var inv_scale = 1/SCALE;
	for (var i = 0; i < MAX; i++) {
		var obj = objs[i];
		var size = obj.size * inv_scale;
		ctx.beginPath();
		ctx.arc(obj.location[0] * inv_scale, obj.location[1] * inv_scale, size, Math.PI* 2, false);
		ctx.moveTo(obj.location[0] * inv_scale, obj.location[1] * inv_scale);
		ctx.lineTo(obj.location[0] * inv_scale + size * Math.cos(obj.rotation), obj.location[1] * inv_scale
			   	+ size * Math.sin(obj.rotation));
		ctx.closePath();
		ctx.stroke();
	}
	document.getElementById("hoge").innerHTML = "calctime:" +msec.toFixed(2) + "ms/f<br />"
		+ "repetation:" + ("_" +repetition).slice(-2);
	setTimeout(ml, 1000/FPS);
}
init();
ml();

function Vec2() {
	this[0] = 0;
	this[1] = 0;
}
function add(a, b, c) {
	a[0] = b[0] + c[0];
	a[1] = b[1] + c[1];
}
function sub(a, b, c) {
	a[0] = b[0] - c[0];
	a[1] = b[1] - c[1];
}
function mul(a, b, c) {
	a[0] = b[0] * c;
	a[1] = b[1] * c;
}
function muladd(a, b, c, d) {
	a[0] = b[0] + c[0] * d;
	a[1] = b[1] + c[1] * d;
}
function dot(a, b) {
	return a[0] * b[0] + a[1] * b[1];
}
function cross(a, b) {
	return a[0] * b[1] - a[1] * b[0];
}
</script>
