<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=Edge"/>
<meta charset="utf-8">
</head>
<body>
	<div id="hoge"></div>
	<canvas id="c" width=256 height=256 style="border:solid 1px black;" ></canvas>
</body>
<script type="text/javascript">

var MAX = 3 + 30; 
var STEP_PER_FRAME = 2; 
var PENALTY = 400 * STEP_PER_FRAME;
var REPETITION_MAX = 50; 
var G = 9.8; 
var SCALE = 0.01; 

var Obj = function() {
	this.id = 0;
	this.location = new Vec2();
	this.locationV = new Vec2();
	this.rotation = 0;
	this.rotationV = 0;
	this.size = 0.05; 
	this.m = 0.01; 
	this.moment = 2.0 / 5.0 * this.m * this.size * this.size;
	this.inv_m = 1.0 / this.m; 
	this.inv_moment = 1.0 / this.moment; 
	this.inv_restCoe = 1.0/0.2; 
	this.inv_fricCoe = 1.0/0.2; 
}
var HitData = function() {
	this.obj1 = null;
	this.obj2 = null;
	this.obj1p = new Vec2();
	this.obj2p = new Vec2();
	this.nVec = new Vec2();
	this.tVec = new Vec2();
	this.m = 0;
	this.moment = 0;
	this.f = 0; 
	this.ft = 0; 
	this.restCoe = 0; 
	this.fricCoe = 0;
}
var HitDataBuf = function() {
	this.id0 = 0;
	this.id1 = 0;
	this.f = 0;
	this.ft = 0;
}
var hitDatas = [];
var hitDataBufs = [];
var hitDatasMAX = MAX * 8;
for (var i = hitDatasMAX; i--;) {
	hitDatas.push(new HitData());
	hitDataBufs.push(new HitDataBuf());
}
hitDataBufs.push(new HitDataBuf());
hitDataBufs[0].id0 = MAX;
var _dt;
var objs = [];
for (var i = 0; i < MAX; i++) {
	var o = new Obj();
	objs.push(o);
	o.id = i;
	o.location[0] = 128 * SCALE + ((Math.random() - 0.5) * 1);
	o.location[1] = 168 * SCALE - i * 0.1;
	o.size = 0.05 + Math.random() * 0.2;
	o.m = o.size*o.size*10;
	o.moment = 2.0 / 5.0 * o.m * o.size * o.size;
	o.inv_m = 1.0 / o.m;
	o.inv_moment = 1.0 / o.moment;
}

objs[0].size = 512 * SCALE;
objs[0].m = 99999;
objs[0].inv_m = 0;
objs[0].moment = 99999;
objs[0].inv_moment = 0;
objs[0].location[0] = 128 * SCALE;
objs[0].location[1] = 220 * SCALE + objs[0].size
objs[1].size = 512 * SCALE;
objs[1].m = 99999;
objs[1].inv_m = 0;
objs[1].moment = 99999;
objs[1].inv_moment = 0;
objs[1].location[0] = 220 * SCALE + objs[1].size;
objs[1].location[1] = 128 * SCALE;
objs[2].m = 99999;
objs[2].inv_m = 0;
objs[2].moment = 99999;
objs[2].inv_moment = 0;
objs[2].size = 512 * SCALE;
objs[2].location[0] = 32 * SCALE - objs[1].size;
objs[2].location[1] = 128 * SCALE;


var ctx = document.getElementById("c").getContext("2d");

var calcD = function(n, hitData) {
	var obj1 = hitData.obj1;
	var obj2 = hitData.obj2;
	var t = cross(n, hitData.obj1p);
	var d = t * t * obj1.inv_moment;
	t = cross(n, hitData.obj2p);
	d += t * t * obj2.inv_moment;
	return 1 / (obj1.inv_m + obj2.inv_m + dot(n, hitData.tVec) * d);
}
var calcDiffVelocity = function(dv,hitData){
	var obj1 = hitData.obj1;
	var obj2 = hitData.obj2;
	sub(dv, obj2.locationV, obj1.locationV);
	dv[0] -= -hitData.obj1p[1] * obj1.rotationV;
	dv[1] -= hitData.obj1p[0] * obj1.rotationV;
	dv[0] += -hitData.obj2p[1] * obj2.rotationV;
	dv[1] += hitData.obj2p[0] * obj2.rotationV;

}

var addForce = function(hitData,force){
	var obj1 = hitData.obj1;
	var obj2 = hitData.obj2;

	if(obj1.inv_m > 0){
		muladd(obj1.locationV,obj1.locationV,force, obj1.inv_m);
		obj1.rotationV += cross(hitData.obj1p, force) * obj1.inv_moment;
	}
	if(obj2.inv_m > 0){
		muladd(obj2.locationV,obj2.locationV,force, -obj2.inv_m);
		obj2.rotationV += -cross(hitData.obj2p, force) * obj2.inv_moment;
	}
}

var repetition = 0; //ステップあたりの反復回数カウント用
var f = function(dt) {
	_dt = 1.0 / dt;
	var dp = new Vec2();
	var dv = new Vec2(); 
	var force = new Vec2();

	hitDatasCount = 0;
	hitDataBufsCount = 0;
	for (var i = 0; i < MAX; i++) {
		var obj1 = objs[i];
		for (var j = i + 1; j < MAX; j++) {
			var obj2 = objs[j];

			if(hitDatasCount>=hitDatas.length-1){
				break;
			}
			sub(dp, obj2.location, obj1.location);
			if (dp[0] * dp[0] + dp[1] * dp[1] < (obj1.size + obj2.size) * (obj1.size + obj2.size)) {
				if (obj1.inv_m == 0 && obj2.inv_m == 0) {
					continue;
				}
				var hitData = hitDatas[hitDatasCount];
				hitDatasCount++;

				hitData.obj1 = obj1;
				hitData.obj2 = obj2;
				hitData.f = 0;
				hitData.ft = 0;
				var d = Math.sqrt(dp[0] * dp[0] + dp[1] * dp[1])
				if (d != 0) {
					mul(hitData.nVec, dp, 1 / d);
				} else {
					mul(hitData.nVec, dp, 0);
				}
				hitData.tVec[0] = -hitData.nVec[1];
				hitData.tVec[1] = hitData.nVec[0];
				mul(hitData.obj1p, hitData.nVec, obj1.size);
				mul(hitData.obj2p, hitData.nVec, -obj2.size);
				hitData.m = calcD(hitData.nVec, hitData);
				hitData.moment = calcD(hitData.tVec, hitData);

				hitData.fricCoe = 1.0/(obj1.inv_fricCoe + obj2.inv_fricCoe);

				sub(dv, obj2.locationV, obj1.locationV);
				hitData.repulsion = dot(dv, hitData.nVec) / (obj1.inv_restCoe + obj2.inv_restCoe);

				for (; 1; hitDataBufsCount++) {
					var hitDataBuf = hitDataBufs[hitDataBufsCount];
					if (hitDataBuf.id0 > i || (hitDataBuf.id0 ==i && hitDataBuf.id1 > j)) {
						break;
					}
					if (hitDataBuf.id0 == i && hitDataBuf.id1 == j) {
						hitData.f = hitDataBuf.f;
						hitData.ft = hitDataBuf.ft;
						break;
					}
				}
			}
		}
	}

	hitDatas[hitDatasCount].obj1=null;

	for (var i = 0;hitDatas[i].obj1; i++) {
		var hitData = hitDatas[i];
		var o = hitData.obj1;
		var o2 = hitData.obj2;
		var n = hitData.nVec;

		mul(force, hitData.nVec, hitData.f * dt);
		addForce( hitData, force);

		mul(force, hitData.tVec, hitData.ft * dt);
		addForce( hitData, force);
	}

	for (var i = 0; i < MAX; i++) {
		var obj = objs[i];
		if (obj.inv_m > 0) {
			obj.locationV[1]+=G*dt;
		}
	}
	for (repetition = 0; repetition < REPETITION_MAX; repetition++) {
		for (var i = 0; i < MAX; i++) {
			var o = objs[i];
			o.oldv0 = o.locationV[0] ;
			o.oldv1 = o.locationV[1] ;
			o.oldangv = o.rotationV ;
		}
		for (var i = 0;hitDatas[i].obj1; i++) {
			var hitData = hitDatas[i];
			var o = hitData.obj1;
			var o2 = hitData.obj2;
			var n = hitData.nVec;

			calcDiffVelocity(dv,hitData);
			var pow = dot(dv, n) + hitData.repulsion;

			var old = hitData.f;
			hitData.f += pow * _dt * hitData.m;
			if (hitData.f > 0) {
				hitData.f = 0;
			}
			mul(force, n, (hitData.f-old) * dt);
			addForce( hitData, force);

			calcDiffVelocity(dv,hitData);
			var max = -hitData.f * _dt * hitData.fricCoe;
			pow = dot(dv, hitData.tVec);
			old = hitData.ft;
			hitData.ft += pow * _dt * hitData.moment;
			if (hitData.ft > max) {
				hitData.ft = max;
			}
			if (hitData.ft < -max) {
				hitData.ft = -max;
			}
			mul(force, hitData.tVec, (hitData.ft-old) * dt);
			addForce( hitData, force);
		}

		var sum= 0;
		for (var i = 0; i < MAX; i++) {
			var obj = objs[i];
			var x = (obj.locationV[0] - obj.oldv0)*obj.m;
			var y = (obj.locationV[1] - obj.oldv1)*obj.m;
			var z = (obj.rotationV - obj.oldangv)*obj.moment;
			sum+=x*x+y*y+z*z ;
		}
		if ( sum<= 0.00000001 * MAX ) {
			break;
		}
	}

	for (var i = 0;hitDatas[i].obj1; i++) {
		var hitData = hitDatas[i];

		add(dp, hitData.obj2p, hitData.obj2.location);
		sub(dp, dp, hitData.obj1.location);
		sub(dp, dp, hitData.obj1p);
		mul(force, dp, PENALTY*dt*hitData.m);

		addForce(hitData,force);
	}
	for (var i = 0; i < MAX; i++) {
		var obj = objs[i];
		if (obj.inv_m ==0 ) continue;

		muladd(obj.location, obj.location, obj.locationV, dt);
		obj.rotation += obj.rotationV * dt;
	}
	for (var i = 0;hitDatas[i].obj1; i++) {
		var hitDataBuf = hitDataBufs[i];
		var hitData = hitDatas[i];
		hitDataBuf.id0 = hitData.obj1.id;
		hitDataBuf.id1 = hitData.obj2.id;
		hitDataBuf.f = hitData.f;
		hitDataBuf.ft = hitData.ft;
	}
	hitDataBufs[i].id0 = MAX;


}
var timesum = 0;
var framecount = 0;
var msec= 0;
var ml = function() {

	var start = Date.now();
	for (var i = 0; i < STEP_PER_FRAME; i++) {
		f(0.033 / STEP_PER_FRAME);
	}
	timesum += (+Date.now() - start);
	framecount++;
	if (framecount == 30) {
		msec= timesum / 30.0;
		framecount = 0;
		timesum = 0;
	}

	ctx.clearRect(0, 0, 256, 256);
	ctx.strokeStyle = "black";
	for (var i = 0; i < MAX; i++) {
		var o = objs[i];
		var size = o.size * 100;
		ctx.beginPath();
		ctx.arc(o.location[0] * 100, o.location[1] * 100, size, Math.PI* 2, false);
		ctx.moveTo(o.location[0] * 100, o.location[1] * 100);
		ctx.lineTo(o.location[0] * 100 + size * Math.cos(o.rotation), o.location[1] * 100 + size * Math
			.sin(o.rotation));
		ctx.closePath();
		ctx.stroke();
	}
	document.getElementById("hoge").innerHTML = "calctime:" +msec.toFixed(3) + "ms/f<br />"
		+ "repetation:" + repetition;
	setTimeout(ml, 33);
}

ml();

//ベクトル計算関数
function Vec2() {
	this[0] = 0;
	this[1] = 0;
}
function add(a, b, c) {
	a[0] = b[0] + c[0];
	a[1] = b[1] + c[1];
}
function sub(a, b, c) {
	a[0] = b[0] - c[0];
	a[1] = b[1] - c[1];
}
function mul(a, b, c) {
	a[0] = b[0] * c;
	a[1] = b[1] * c;
}
function muladd(a, b, c, d) {
	a[0] = b[0] + c[0] * d;
	a[1] = b[1] + c[1] * d;
}
function dot(a, b) {
	return a[0] * b[0] + a[1] * b[1];
}
function cross(a, b) {
	return a[0] * b[1] - a[1] * b[0];
}
</script>
